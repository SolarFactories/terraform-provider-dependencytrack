package provider

import (
	"context"
	"fmt"

	dtrack "github.com/DependencyTrack/client-go"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
	_ resource.Resource                = &componentResource{}
	_ resource.ResourceWithConfigure   = &componentResource{}
	_ resource.ResourceWithImportState = &componentResource{}
)

type (
	componentResource struct {
		client *dtrack.Client
		semver *Semver
	}

	componentResourceModel struct {
		ID          types.String                 `tfsdk:"id"`
		Project     types.String                 `tfsdk:"project"`
		Author      types.String                 `tfsdk:"author"`
		Publisher   types.String                 `tfsdk:"publisher"`
		Group       types.String                 `tfsdk:"group"`
		Name        types.String                 `tfsdk:"name"`
		Version     types.String                 `tfsdk:"version"`
		Classifier  types.String                 `tfsdk:"classifier"`
		Filename    types.String                 `tfsdk:"filename"`
		Extension   types.String                 `tfsdk:"extension"`
		CPE         types.String                 `tfsdk:"cpe"`
		PURL        types.String                 `tfsdk:"purl"`
		SWID        types.String                 `tfsdk:"swid"`
		Description types.String                 `tfsdk:"description"`
		Copyright   types.String                 `tfsdk:"copyright"`
		License     types.String                 `tfsdk:"license"`
		Notes       types.String                 `tfsdk:"notes"`
		Hashes      componentHashesResourceModel `tfsdk:"hashes"`
		Internal    types.Bool                   `tfsdk:"internal"`
	}

	componentHashesResourceModel struct {
		MD5         types.String `tfsdk:"md5"`
		SHA1        types.String `tfsdk:"sha1"`
		SHA256      types.String `tfsdk:"sha256"`
		SHA384      types.String `tfsdk:"sha384"`
		SHA512      types.String `tfsdk:"sha512"`
		SHA3_256    types.String `tfsdk:"sha3_256"`
		SHA3_384    types.String `tfsdk:"sha3_384"`
		SHA3_512    types.String `tfsdk:"sha_512"`
		BLAKE2b_256 types.String `tfsdk:"blake2b_256"`
		BLAKE2b_384 types.String `tfsdk:"blake2b_384"`
		BLAKE2b_512 types.String `tfsdk:"bake2b_512"`
		BLAKE3      types.String `tfsdk:"blake3"`
	}
)

func NewComponentResource() resource.Resource {
	return &componentResource{}
}

func (*componentResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_component"
}

func (*componentResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a Component, within a Project.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "UUID for the Component, as generated by DependencyTrack.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"project": schema.StringAttribute{
				Description: "UUID for the Project that contains this Component.",
				Required:    true,
			},
			"name": schema.StringAttribute{
				Description: "Name of the Component.",
				Required:    true,
			},
			"version": schema.StringAttribute{
				Description: "Version of the Component.",
				Required:    true,
			},
			"description": schema.StringAttribute{
				Description: "Description of the Component.",
				Optional:    true,
			},
			"author": schema.StringAttribute{
				Description: "Author of the Component.",
				Optional:    true,
			},
			"publisher": schema.StringAttribute{
				Description: "Publisher of the Component.",
				Optional:    true,
			},
			"group": schema.StringAttribute{
				Description: "Group of the Component.",
				Optional:    true,
			},
			"classifier": schema.StringAttribute{
				Description: "Classifier of the Component. Defaults to APPLICATION. See DependencyTrack for valid options.",
				Optional:    true,
				Computed:    true,
			},
			"filename": schema.StringAttribute{
				Description: "Filename of the Component.",
				Optional:    true,
			},
			"extension": schema.StringAttribute{
				Description: "Filename extension of the Component.",
				Optional:    true,
			},
			"cpe": schema.StringAttribute{
				Description: "Common Platform Enumeration of the Component. Standardised format v2.2 / v2.3 from MITRE / NIST.",
				Optional:    true,
			},
			"purl": schema.StringAttribute{
				Description: "Package URL of the Component. MUST be in standardised format to be saved. See DependencyTrack for format.",
				Optional:    true,
			},
			"swid": schema.StringAttribute{
				Description: "SWID Tag ID. ISO/IEC 19770-2:2015.",
				Optional:    true,
			},
			"copyright": schema.StringAttribute{
				Description: "Copyright of the Component.",
				Optional:    true,
			},
			"license": schema.StringAttribute{
				Description: "License of the Component. See DependencyTrack for valid options.",
				Optional:    true,
			},
			"notes": schema.StringAttribute{
				Description: "Notes to associate with the Component.",
				Optional:    true,
			},
			"internal": schema.BoolAttribute{
				Description: "Whether the Component is internal, or external.",
				Optional:    true,
			},
			"hashes": schema.SingleNestedAttribute{
				Description: "Hashes of the Component.",
				Optional:    true,
				Attributes: map[string]schema.Attribute{
					"md5": schema.StringAttribute{
						Description: "MD5 hash of the Component.",
						Optional:    true,
					},
					"sha1": schema.StringAttribute{
						Description: "SHA1 hash of the Component.",
						Optional:    true,
					},
					"sha256": schema.StringAttribute{
						Description: "SHA256 hash of the Component.",
						Optional:    true,
					},
					"sha384": schema.StringAttribute{
						Description: "SHA384 hash of the Component.",
						Optional:    true,
					},
					"sha512": schema.StringAttribute{
						Description: "SHA512 hash of the Component.",
						Optional:    true,
					},
					"sha3_256": schema.StringAttribute{
						Description: "SHA3-256 hash of the Component.",
						Optional:    true,
					},
					"sha3_384": schema.StringAttribute{
						Description: "SHA3-384 hash of the Component.",
						Optional:    true,
					},
					"sha3_512": schema.StringAttribute{
						Description: "SHA3-512 hash of the Component.",
						Optional:    true,
					},
					"blake2b_256": schema.StringAttribute{
						Description: "BLAKE2b-256 hash of the Component.",
						Optional:    true,
					},
					"blake2b_384": schema.StringAttribute{
						Description: "BLAKE2b-384 hash of the Component.",
						Optional:    true,
					},
					"blake2b_512": schema.StringAttribute{
						Description: "BLAKE2b-512 hash of the Component.",
						Optional:    true,
					},
					"blake3": schema.StringAttribute{
						Description: "BLAKE3 hash of the Component.",
						Optional:    true,
					},
				},
			},
		},
	}
}

func (r *componentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan componentResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	projectID, diag := TryParseUUID(plan.Project, LifecycleCreate, path.Root("project"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
		return
	}
	componentReq := dtrack.Component{
		Author:      plan.Author.ValueString(),
		Publisher:   plan.Author.ValueString(),
		Group:       plan.Group.ValueString(),
		Name:        plan.Name.ValueString(),
		Version:     plan.Version.ValueString(),
		Classifier:  plan.Classifier.ValueString(),
		FileName:    plan.Filename.ValueString(),
		Extension:   plan.Extension.ValueString(),
		MD5:         plan.Hashes.MD5.ValueString(),
		SHA1:        plan.Hashes.SHA1.ValueString(),
		SHA256:      plan.Hashes.SHA256.ValueString(),
		SHA384:      plan.Hashes.SHA384.ValueString(),
		SHA512:      plan.Hashes.SHA512.ValueString(),
		SHA3_256:    plan.Hashes.SHA3_256.ValueString(),
		SHA3_384:    plan.Hashes.SHA3_384.ValueString(),
		SHA3_512:    plan.Hashes.SHA3_512.ValueString(),
		BLAKE2b_256: plan.Hashes.BLAKE2b_256.ValueString(),
		BLAKE2b_384: plan.Hashes.BLAKE2b_384.ValueString(),
		BLAKE2b_512: plan.Hashes.BLAKE2b_512.ValueString(),
		BLAKE3:      plan.Hashes.BLAKE3.ValueString(),
		CPE:         plan.CPE.ValueString(),
		PURL:        plan.PURL.ValueString(),
		SWIDTagID:   plan.SWID.ValueString(),
		Internal:    plan.Internal.ValueBool(),
		Description: plan.Description.ValueString(),
		Copyright:   plan.Copyright.ValueString(),
		License:     plan.License.ValueString(),
		Notes:       plan.Notes.ValueString(),
		Project: &dtrack.Project{
			UUID: projectID,
		},
	}
	if plan.Classifier.IsUnknown() {
		componentReq.Classifier = "APPLICATION"
	}
	tflog.Debug(ctx, "Creating Component", map[string]any{
		"author":      componentReq.Author,
		"publisher":   componentReq.Publisher,
		"group":       componentReq.Group,
		"name":        componentReq.Name,
		"version":     componentReq.Version,
		"classifier":  componentReq.Classifier,
		"filename":    componentReq.FileName,
		"extension":   componentReq.Extension,
		"md5":         componentReq.MD5,
		"sha1":        componentReq.SHA1,
		"sha256":      componentReq.SHA256,
		"sha384":      componentReq.SHA384,
		"sha512":      componentReq.SHA3_512,
		"sha3_256":    componentReq.SHA3_256,
		"sha3_384":    componentReq.SHA3_384,
		"sha3_512":    componentReq.SHA3_512,
		"blake2b_256": componentReq.BLAKE2b_256,
		"blake2b_384": componentReq.BLAKE2b_384,
		"blake2b_512": componentReq.BLAKE2b_512,
		"blake3":      componentReq.BLAKE3,
		"cpe":         componentReq.CPE,
		"purl":        componentReq.PURL,
		"swid":        componentReq.SWIDTagID,
		"internal":    componentReq.Internal,
		"description": componentReq.Description,
		"copyright":   componentReq.Copyright,
		"license":     componentReq.License,
		"notes":       componentReq.Notes,
		"project":     componentReq.Project.UUID.String(),
	})
	componentRes, err := r.client.Component.Create(ctx, projectID, componentReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating Component.",
			"Unexpected error: "+err.Error(),
		)
		return
	}

	plan = componentResourceModel{
		ID:          types.StringValue(componentRes.UUID.String()),
		Project:     types.StringValue(componentRes.Project.UUID.String()),
		Author:      types.StringValue(componentRes.Author),
		Publisher:   types.StringValue(componentRes.Publisher),
		Group:       types.StringValue(componentRes.Group),
		Name:        types.StringValue(componentRes.Name),
		Version:     types.StringValue(componentRes.Version),
		Classifier:  types.StringValue(componentRes.Classifier),
		Filename:    types.StringValue(componentRes.FileName),
		Extension:   types.StringValue(componentRes.Extension),
		CPE:         types.StringValue(componentRes.CPE),
		PURL:        types.StringValue(componentRes.PURL),
		SWID:        types.StringValue(componentRes.SWIDTagID),
		Description: types.StringValue(componentRes.Description),
		Copyright:   types.StringValue(componentRes.Copyright),
		License:     types.StringValue(componentRes.License),
		Notes:       types.StringValue(componentRes.Notes),
		Internal:    types.BoolValue(componentRes.Internal),
		Hashes: componentHashesResourceModel{
			MD5:         types.StringValue(componentRes.MD5),
			SHA1:        types.StringValue(componentRes.SHA1),
			SHA256:      types.StringValue(componentRes.SHA256),
			SHA384:      types.StringValue(componentRes.SHA384),
			SHA512:      types.StringValue(componentRes.SHA512),
			SHA3_256:    types.StringValue(componentRes.SHA3_256),
			SHA3_384:    types.StringValue(componentRes.SHA3_384),
			SHA3_512:    types.StringValue(componentRes.SHA3_512),
			BLAKE2b_256: types.StringValue(componentRes.BLAKE2b_256),
			BLAKE2b_384: types.StringValue(componentRes.BLAKE2b_384),
			BLAKE2b_512: types.StringValue(componentRes.BLAKE2b_512),
			BLAKE3:      types.StringValue(componentRes.BLAKE3),
		},
	}

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Created Component", map[string]any{
		"id":          plan.ID.ValueString(),
		"author":      plan.Author.ValueString(),
		"publisher":   plan.Publisher.ValueString(),
		"group":       plan.Group.ValueString(),
		"name":        plan.Name.ValueString(),
		"version":     plan.Version.ValueString(),
		"classifier":  plan.Classifier.ValueString(),
		"filename":    plan.Filename.ValueString(),
		"extension":   plan.Extension.ValueString(),
		"md5":         plan.Hashes.MD5.ValueString(),
		"sha1":        plan.Hashes.SHA1.ValueString(),
		"sha256":      plan.Hashes.SHA256.ValueString(),
		"sha384":      plan.Hashes.SHA384.ValueString(),
		"sha512":      plan.Hashes.SHA3_512.ValueString(),
		"sha3_256":    plan.Hashes.SHA3_256.ValueString(),
		"sha3_384":    plan.Hashes.SHA3_384.ValueString(),
		"sha3_512":    plan.Hashes.SHA3_512.ValueString(),
		"blake2b_256": plan.Hashes.BLAKE2b_256.ValueString(),
		"blake2b_384": plan.Hashes.BLAKE2b_384.ValueString(),
		"blake2b_512": plan.Hashes.BLAKE2b_512.ValueString(),
		"blake3":      plan.Hashes.BLAKE3.ValueString(),
		"cpe":         plan.CPE.ValueString(),
		"purl":        plan.PURL.ValueString(),
		"swid":        plan.SWID.ValueString(),
		"internal":    plan.Internal.ValueBool(),
		"description": plan.Description.ValueString(),
		"copyright":   plan.Copyright.ValueString(),
		"license":     plan.License.ValueString(),
		"notes":       plan.Notes.ValueString(),
		"project":     plan.Project.ValueString(),
	})
}

func (r *componentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state componentResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	id, diag := TryParseUUID(state.ID, LifecycleRead, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
		return
	}
	tflog.Debug(ctx, "Reading Component", map[string]any{
		// TODO.
	})
	component, err := r.client.Component.Get(ctx, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Read, unable to get Component",
			"Error in Component: "+id.String()+", from error: "+err.Error(),
		)
		return
	}
	state = componentResourceModel{
		ID:          types.StringValue(component.UUID.String()),
		Project:     types.StringValue(component.Project.UUID.String()),
		Author:      types.StringValue(component.Author),
		Publisher:   types.StringValue(component.Publisher),
		Group:       types.StringValue(component.Group),
		Name:        types.StringValue(component.Name),
		Version:     types.StringValue(component.Version),
		Classifier:  types.StringValue(component.Classifier),
		Filename:    types.StringValue(component.FileName),
		Extension:   types.StringValue(component.Extension),
		CPE:         types.StringValue(component.CPE),
		PURL:        types.StringValue(component.PURL),
		SWID:        types.StringValue(component.SWIDTagID),
		Description: types.StringValue(component.Description),
		Copyright:   types.StringValue(component.Copyright),
		License:     types.StringValue(component.License),
		Notes:       types.StringValue(component.Notes),
		Internal:    types.BoolValue(component.Internal),
		Hashes: componentHashesResourceModel{
			MD5:         types.StringValue(component.MD5),
			SHA1:        types.StringValue(component.SHA1),
			SHA256:      types.StringValue(component.SHA256),
			SHA384:      types.StringValue(component.SHA384),
			SHA512:      types.StringValue(component.SHA512),
			SHA3_256:    types.StringValue(component.SHA3_256),
			SHA3_384:    types.StringValue(component.SHA3_384),
			SHA3_512:    types.StringValue(component.SHA3_512),
			BLAKE2b_256: types.StringValue(component.BLAKE2b_256),
			BLAKE2b_384: types.StringValue(component.BLAKE2b_384),
			BLAKE2b_512: types.StringValue(component.BLAKE2b_512),
			BLAKE3:      types.StringValue(component.BLAKE3),
		},
	}

	diags = resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Read Component", map[string]any{
		// TODO.
	})
}

func (r *componentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan componentResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	componentID, diag := TryParseUUID(plan.ID, LifecycleUpdate, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	projectID, diag := TryParseUUID(plan.Project, LifecycleUpdate, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	if resp.Diagnostics.HasError() {
		return
	}

	component := dtrack.Component{
		UUID:        componentID,
		Author:      plan.Author.ValueString(),
		Publisher:   plan.Author.ValueString(),
		Group:       plan.Group.ValueString(),
		Name:        plan.Name.ValueString(),
		Version:     plan.Version.ValueString(),
		Classifier:  plan.Classifier.ValueString(),
		FileName:    plan.Filename.ValueString(),
		Extension:   plan.Extension.ValueString(),
		MD5:         plan.Hashes.MD5.ValueString(),
		SHA1:        plan.Hashes.SHA1.ValueString(),
		SHA256:      plan.Hashes.SHA256.ValueString(),
		SHA384:      plan.Hashes.SHA384.ValueString(),
		SHA512:      plan.Hashes.SHA512.ValueString(),
		SHA3_256:    plan.Hashes.SHA3_256.ValueString(),
		SHA3_384:    plan.Hashes.SHA3_384.ValueString(),
		SHA3_512:    plan.Hashes.SHA3_512.ValueString(),
		BLAKE2b_256: plan.Hashes.BLAKE2b_256.ValueString(),
		BLAKE2b_384: plan.Hashes.BLAKE2b_384.ValueString(),
		BLAKE2b_512: plan.Hashes.BLAKE2b_512.ValueString(),
		BLAKE3:      plan.Hashes.BLAKE3.ValueString(),
		CPE:         plan.CPE.ValueString(),
		PURL:        plan.PURL.ValueString(),
		SWIDTagID:   plan.SWID.ValueString(),
		Internal:    plan.Internal.ValueBool(),
		Description: plan.Description.ValueString(),
		Copyright:   plan.Copyright.ValueString(),
		License:     plan.License.ValueString(),
		Notes:       plan.Notes.ValueString(),
		Project: &dtrack.Project{
			UUID: projectID,
		},
	}

	tflog.Debug(ctx, "Updating Component", map[string]any{
		// TODO.
	})
	componentRes, err := r.client.Component.Update(ctx, component)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to update Component.",
			"Error in: "+componentID.String()+", from: "+err.Error(),
		)
		return
	}

	plan = componentResourceModel{
		ID:          types.StringValue(componentRes.UUID.String()),
		Project:     types.StringValue(componentRes.Project.UUID.String()),
		Author:      types.StringValue(componentRes.Author),
		Publisher:   types.StringValue(componentRes.Publisher),
		Group:       types.StringValue(componentRes.Group),
		Name:        types.StringValue(componentRes.Name),
		Version:     types.StringValue(componentRes.Version),
		Classifier:  types.StringValue(componentRes.Classifier),
		Filename:    types.StringValue(componentRes.FileName),
		Extension:   types.StringValue(componentRes.Extension),
		CPE:         types.StringValue(componentRes.CPE),
		PURL:        types.StringValue(componentRes.PURL),
		SWID:        types.StringValue(componentRes.SWIDTagID),
		Description: types.StringValue(componentRes.Description),
		Copyright:   types.StringValue(componentRes.Copyright),
		License:     types.StringValue(componentRes.License),
		Notes:       types.StringValue(componentRes.Notes),
		Internal:    types.BoolValue(componentRes.Internal),
		Hashes: componentHashesResourceModel{
			MD5:         types.StringValue(componentRes.MD5),
			SHA1:        types.StringValue(componentRes.SHA1),
			SHA256:      types.StringValue(componentRes.SHA256),
			SHA384:      types.StringValue(componentRes.SHA384),
			SHA512:      types.StringValue(componentRes.SHA512),
			SHA3_256:    types.StringValue(componentRes.SHA3_256),
			SHA3_384:    types.StringValue(componentRes.SHA3_384),
			SHA3_512:    types.StringValue(componentRes.SHA3_512),
			BLAKE2b_256: types.StringValue(componentRes.BLAKE2b_256),
			BLAKE2b_384: types.StringValue(componentRes.BLAKE2b_384),
			BLAKE2b_512: types.StringValue(componentRes.BLAKE2b_512),
			BLAKE3:      types.StringValue(componentRes.BLAKE3),
		},
	}

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Updated Component", map[string]any{
		// TODO.
	})
}

func (r *componentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state componentResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	id, diag := TryParseUUID(state.ID, LifecycleDelete, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
		return
	}

	tflog.Debug(ctx, "Deleting Component", map[string]any{
		"id": id.String(),
		// TODO
	})
	err := r.client.Component.Delete(ctx, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to delete component",
			"Unexpected error when trying to delete component with id: "+id.String()+", error: "+err.Error(),
		)
		return
	}
	tflog.Debug(ctx, "Deleted Component", map[string]any{
		"id": state.ID.ValueString(),
		// TODO
	})
}

func (r *componentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Importing Component", map[string]any{
		"id": req.ID,
	})
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Imported Component", map[string]any{
		"id": req.ID,
	})
}

func (r *componentResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	clientInfoData, ok := req.ProviderData.(clientInfo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Configure Type",
			fmt.Sprintf("Expected provider.clientInfo, got %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = clientInfoData.client
	r.semver = clientInfoData.semver
}
