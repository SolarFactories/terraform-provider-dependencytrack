package provider

import (
	"context"
	"fmt"

	dtrack "github.com/DependencyTrack/client-go"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
	_ resource.Resource                = &componentResource{}
	_ resource.ResourceWithConfigure   = &componentResource{}
	_ resource.ResourceWithImportState = &componentResource{}
)

type (
	componentResource struct {
		client *dtrack.Client
		semver *Semver
	}

	componentResourceModel struct {
		Hashes      *componentHashesResourceModel `tfsdk:"hashes"`
		ID          types.String                  `tfsdk:"id"`
		Project     types.String                  `tfsdk:"project"`
		Author      types.String                  `tfsdk:"author"`
		Publisher   types.String                  `tfsdk:"publisher"`
		Group       types.String                  `tfsdk:"group"`
		Name        types.String                  `tfsdk:"name"`
		Version     types.String                  `tfsdk:"version"`
		Classifier  types.String                  `tfsdk:"classifier"`
		Filename    types.String                  `tfsdk:"filename"`
		Extension   types.String                  `tfsdk:"extension"`
		CPE         types.String                  `tfsdk:"cpe"`
		PURL        types.String                  `tfsdk:"purl"`
		SWID        types.String                  `tfsdk:"swid"`
		Description types.String                  `tfsdk:"description"`
		Copyright   types.String                  `tfsdk:"copyright"`
		License     types.String                  `tfsdk:"license"`
		Notes       types.String                  `tfsdk:"notes"`
	}

	componentHashesResourceModel struct {
		MD5         types.String `tfsdk:"md5"`
		SHA1        types.String `tfsdk:"sha1"`
		SHA256      types.String `tfsdk:"sha256"`
		SHA384      types.String `tfsdk:"sha384"`
		SHA512      types.String `tfsdk:"sha512"`
		SHA3_256    types.String `tfsdk:"sha3_256"`
		SHA3_384    types.String `tfsdk:"sha3_384"`
		SHA3_512    types.String `tfsdk:"sha3_512"`
		BLAKE2b_256 types.String `tfsdk:"blake2b_256"`
		BLAKE2b_384 types.String `tfsdk:"blake2b_384"`
		BLAKE2b_512 types.String `tfsdk:"blake2b_512"`
		BLAKE3      types.String `tfsdk:"blake3"`
	}
)

func NewComponentResource() resource.Resource {
	return &componentResource{}
}

func (*componentResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_component"
}

func (*componentResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a Component, within a Project.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "UUID for the Component, as generated by DependencyTrack.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"project": schema.StringAttribute{
				Description: "UUID for the Project that contains this Component.",
				Required:    true,
			},
			"name": schema.StringAttribute{
				Description: "Name of the Component.",
				Required:    true,
			},
			"version": schema.StringAttribute{
				Description: "Version of the Component.",
				Required:    true,
			},
			"description": schema.StringAttribute{
				Description: "Description of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"author": schema.StringAttribute{
				Description: "Author of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"publisher": schema.StringAttribute{
				Description: "Publisher of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"group": schema.StringAttribute{
				Description: "Group of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"classifier": schema.StringAttribute{
				Description: "Classifier of the Component. Defaults to LIBRARY. See DependencyTrack for valid options.",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("LIBRARY"),
			},
			"filename": schema.StringAttribute{
				Description: "Filename of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"extension": schema.StringAttribute{
				Description: "Filename extension of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"cpe": schema.StringAttribute{
				Description: "Common Platform Enumeration of the Component. Standardised format v2.2 / v2.3 from MITRE / NIST.",
				Optional:    true,
				Computed:    true,
			},
			"purl": schema.StringAttribute{
				Description: "Package URL of the Component. MUST be in standardised format to be saved. See DependencyTrack for format.",
				Optional:    true,
				Computed:    true,
			},
			"swid": schema.StringAttribute{
				Description: "SWID Tag ID. ISO/IEC 19770-2:2015.",
				Optional:    true,
				Computed:    true,
			},
			"copyright": schema.StringAttribute{
				Description: "Copyright of the Component.",
				Optional:    true,
				Computed:    true,
			},
			"license": schema.StringAttribute{
				Description: "License of the Component. See DependencyTrack for valid options.",
				Optional:    true,
				Computed:    true,
			},
			"notes": schema.StringAttribute{
				Description: "Notes to associate with the Component.",
				Optional:    true,
				Computed:    true,
			},
			"hashes": schema.SingleNestedAttribute{
				Description: "Hashes of the Component.",
				Required:    true,
				Attributes: map[string]schema.Attribute{
					"md5": schema.StringAttribute{
						Description: "MD5 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha1": schema.StringAttribute{
						Description: "SHA1 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha256": schema.StringAttribute{
						Description: "SHA256 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha384": schema.StringAttribute{
						Description: "SHA384 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha512": schema.StringAttribute{
						Description: "SHA512 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha3_256": schema.StringAttribute{
						Description: "SHA3-256 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha3_384": schema.StringAttribute{
						Description: "SHA3-384 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"sha3_512": schema.StringAttribute{
						Description: "SHA3-512 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"blake2b_256": schema.StringAttribute{
						Description: "BLAKE2b-256 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"blake2b_384": schema.StringAttribute{
						Description: "BLAKE2b-384 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"blake2b_512": schema.StringAttribute{
						Description: "BLAKE2b-512 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
					"blake3": schema.StringAttribute{
						Description: "BLAKE3 hash of the Component.",
						Optional:    true,
						Computed:    true,
					},
				},
			},
		},
	}
}

func (r *componentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan componentResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	componentReq := plan.ToSdk(LifecycleCreate, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Creating Component", componentDebug(*componentReq))
	componentRes, err := r.client.Component.Create(ctx, componentReq.Project.UUID, *componentReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating Component.",
			"Unexpected error: "+err.Error(),
		)
		return
	}
	plan = componentToModel(componentRes)

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Created Component", plan.debug())
}

func (r *componentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state componentResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	if state.Hashes == nil {
		// Account for when called from `ImportState`.
		state.Hashes = &componentHashesResourceModel{}
	}

	id, diagnostic := TryParseUUID(state.ID, LifecycleRead, path.Root("id"))
	if diagnostic != nil {
		resp.Diagnostics.Append(diagnostic)
		return
	}
	tflog.Debug(ctx, "Reading Component", state.debug())
	component, err := r.client.Component.Get(ctx, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Read, unable to get Component",
			"Error in Component: "+id.String()+", from error: "+err.Error(),
		)
		return
	}
	state = componentToModel(component)

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Read Component", state.debug())
}

func (r *componentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan componentResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	component := plan.ToSdk(LifecycleUpdate, &resp.Diagnostics)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, "Updating Component", componentDebug(*component))
	componentRes, err := r.client.Component.Update(ctx, *component)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to update Component.",
			"Error in: "+component.UUID.String()+", from: "+err.Error(),
		)
		return
	}

	plan = componentToModel(componentRes)

	diags = resp.State.Set(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Updated Component", plan.debug())
}

func (r *componentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state componentResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	id, diagnostic := TryParseUUID(state.ID, LifecycleDelete, path.Root("id"))
	if diagnostic != nil {
		resp.Diagnostics.Append(diagnostic)
		return
	}

	tflog.Debug(ctx, "Deleting Component", state.debug())
	err := r.client.Component.Delete(ctx, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to delete component",
			"Unexpected error when trying to delete component with id: "+id.String()+", error: "+err.Error(),
		)
		return
	}
	tflog.Debug(ctx, "Deleted Component", state.debug())
}

func (*componentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Importing Component", map[string]any{
		"id": req.ID,
	})
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Imported Component", map[string]any{
		"id": req.ID,
	})
}

func (r *componentResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	clientInfoData, ok := req.ProviderData.(clientInfo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Configure Type",
			fmt.Sprintf("Expected provider.clientInfo, got %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = clientInfoData.client
	r.semver = clientInfoData.semver
}

func (model componentResourceModel) ToSdk(lifecycle LifecycleAction, d *diag.Diagnostics) *dtrack.Component {
	projectID, diagnostic := TryParseUUID(model.Project, lifecycle, path.Root("project"))
	if diagnostic != nil {
		d.Append(diagnostic)
		return nil
	}

	component := dtrack.Component{
		Author:      model.Author.ValueString(),
		Publisher:   model.Publisher.ValueString(),
		Group:       model.Group.ValueString(),
		Name:        model.Name.ValueString(),
		Version:     model.Version.ValueString(),
		Classifier:  model.Classifier.ValueString(),
		FileName:    model.Filename.ValueString(),
		Extension:   model.Extension.ValueString(),
		MD5:         model.Hashes.MD5.ValueString(),
		SHA1:        model.Hashes.SHA1.ValueString(),
		SHA256:      model.Hashes.SHA256.ValueString(),
		SHA384:      model.Hashes.SHA384.ValueString(),
		SHA512:      model.Hashes.SHA512.ValueString(),
		SHA3_256:    model.Hashes.SHA3_256.ValueString(),
		SHA3_384:    model.Hashes.SHA3_384.ValueString(),
		SHA3_512:    model.Hashes.SHA3_512.ValueString(),
		BLAKE2b_256: model.Hashes.BLAKE2b_256.ValueString(),
		BLAKE2b_384: model.Hashes.BLAKE2b_384.ValueString(),
		BLAKE2b_512: model.Hashes.BLAKE2b_512.ValueString(),
		BLAKE3:      model.Hashes.BLAKE3.ValueString(),
		CPE:         model.CPE.ValueString(),
		PURL:        model.PURL.ValueString(),
		SWIDTagID:   model.SWID.ValueString(),
		Description: model.Description.ValueString(),
		Copyright:   model.Copyright.ValueString(),
		License:     model.License.ValueString(),
		Notes:       model.Notes.ValueString(),
		Project: &dtrack.Project{
			UUID: projectID,
		},
	}
	if lifecycle != LifecycleCreate {
		componentID, diagnostic := TryParseUUID(model.ID, lifecycle, path.Root("id"))
		if diagnostic != nil {
			d.Append(diagnostic)
			return nil
		}
		component.UUID = componentID
	}
	return &component
}

func componentToModel(component dtrack.Component) componentResourceModel {
	model := componentResourceModel{
		ID:          types.StringValue(component.UUID.String()),
		Project:     types.StringValue(component.Project.UUID.String()),
		Author:      types.StringValue(component.Author),
		Publisher:   types.StringValue(component.Publisher),
		Group:       types.StringValue(component.Group),
		Name:        types.StringValue(component.Name),
		Version:     types.StringValue(component.Version),
		Classifier:  types.StringValue(component.Classifier),
		Filename:    types.StringValue(component.FileName),
		Extension:   types.StringValue(component.Extension),
		CPE:         types.StringValue(component.CPE),
		PURL:        types.StringValue(component.PURL),
		SWID:        types.StringValue(component.SWIDTagID),
		Description: types.StringValue(component.Description),
		Copyright:   types.StringValue(component.Copyright),
		License:     types.StringValue(component.License),
		Notes:       types.StringValue(component.Notes),
		Hashes: &componentHashesResourceModel{
			MD5:         types.StringValue(component.MD5),
			SHA1:        types.StringValue(component.SHA1),
			SHA256:      types.StringValue(component.SHA256),
			SHA384:      types.StringValue(component.SHA384),
			SHA512:      types.StringValue(component.SHA512),
			SHA3_256:    types.StringValue(component.SHA3_256),
			SHA3_384:    types.StringValue(component.SHA3_384),
			SHA3_512:    types.StringValue(component.SHA3_512),
			BLAKE2b_256: types.StringValue(component.BLAKE2b_256),
			BLAKE2b_384: types.StringValue(component.BLAKE2b_384),
			BLAKE2b_512: types.StringValue(component.BLAKE2b_512),
			BLAKE3:      types.StringValue(component.BLAKE3),
		},
	}
	return model
}

func componentDebug(component dtrack.Component) map[string]any {
	return map[string]any{
		"id":          component.UUID.String(),
		"author":      component.Author,
		"publisher":   component.Publisher,
		"group":       component.Group,
		"name":        component.Name,
		"version":     component.Version,
		"classifier":  component.Classifier,
		"filename":    component.FileName,
		"extension":   component.Extension,
		"md5":         component.MD5,
		"sha1":        component.SHA1,
		"sha256":      component.SHA256,
		"sha384":      component.SHA384,
		"sha512":      component.SHA512,
		"sha3_256":    component.SHA3_256,
		"sha3_384":    component.SHA3_384,
		"sha3_512":    component.SHA3_512,
		"blake2b_256": component.BLAKE2b_256,
		"blake2b_384": component.BLAKE2b_384,
		"blake2b_512": component.BLAKE2b_512,
		"blake3":      component.BLAKE3,
		"cpe":         component.CPE,
		"purl":        component.PURL,
		"swid":        component.SWIDTagID,
		"description": component.Description,
		"copyright":   component.Copyright,
		"license":     component.License,
		"notes":       component.Notes,
		"project":     component.Project.UUID.String(),
	}
}

func (model componentResourceModel) debug() map[string]any {
	return map[string]any{
		"id":          model.ID.ValueString(),
		"author":      model.Author.ValueString(),
		"publisher":   model.Publisher.ValueString(),
		"group":       model.Group.ValueString(),
		"name":        model.Name.ValueString(),
		"version":     model.Version.ValueString(),
		"classifier":  model.Classifier.ValueString(),
		"filename":    model.Filename.ValueString(),
		"extension":   model.Extension.ValueString(),
		"md5":         model.Hashes.MD5.ValueString(),
		"sha1":        model.Hashes.SHA1.ValueString(),
		"sha256":      model.Hashes.SHA256.ValueString(),
		"sha384":      model.Hashes.SHA384.ValueString(),
		"sha512":      model.Hashes.SHA512.ValueString(),
		"sha3_256":    model.Hashes.SHA3_256.ValueString(),
		"sha3_384":    model.Hashes.SHA3_384.ValueString(),
		"sha3_512":    model.Hashes.SHA3_512.ValueString(),
		"blake2b_256": model.Hashes.BLAKE2b_256.ValueString(),
		"blake2b_384": model.Hashes.BLAKE2b_384.ValueString(),
		"blake2b_512": model.Hashes.BLAKE2b_512.ValueString(),
		"blake3":      model.Hashes.BLAKE3.ValueString(),
		"cpe":         model.CPE.ValueString(),
		"purl":        model.PURL.ValueString(),
		"swid":        model.SWID.ValueString(),
		"description": model.Description.ValueString(),
		"copyright":   model.Copyright.ValueString(),
		"license":     model.License.ValueString(),
		"notes":       model.Notes.ValueString(),
		"project":     model.Project.ValueString(),
	}
}
