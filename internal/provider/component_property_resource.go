package provider

import (
	"context"
	"fmt"
	"strings"

	dtrack "github.com/DependencyTrack/client-go"
	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
	_ resource.Resource                = &componentPropertyResource{}
	_ resource.ResourceWithConfigure   = &componentPropertyResource{}
	_ resource.ResourceWithImportState = &componentPropertyResource{}
)

type (
	componentPropertyResource struct {
		client *dtrack.Client
		semver *Semver
	}

	componentPropertyResourceModel struct {
		ID          types.String `tfsdk:"id"`
		Component   types.String `tfsdk:"component"`
		Group       types.String `tfsdk:"group"`
		Name        types.String `tfsdk:"name"`
		Value       types.String `tfsdk:"value"`
		Type        types.String `tfsdk:"type"`
		Description types.String `tfsdk:"description"`
	}
)

func NewComponentPropertyResource() resource.Resource {
	return &componentPropertyResource{}
}

func (*componentPropertyResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_component_property"
}

func (*componentPropertyResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a Component Property.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "UUID for the Component Property as generated by DependencyTrack.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"component": schema.StringAttribute{
				Description: "UUID for the Component, to which to assign Property.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"group": schema.StringAttribute{
				Description: "Group name of the Component Property.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"name": schema.StringAttribute{
				Description: "Property name of the Component Property.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"value": schema.StringAttribute{
				Description: "Value of the Component Property.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"type": schema.StringAttribute{
				Description: "Type of the Component Property. See DependencyTrack for valid enum values.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"description": schema.StringAttribute{
				Description: "Description of the Component Property.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (r *componentPropertyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan componentPropertyResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	componentID, diag := TryParseUUID(plan.Component, LifecycleCreate, path.Root("component"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
		return
	}

	propertyReq := dtrack.ComponentProperty{
		Group:       plan.Group.ValueString(),
		Name:        plan.Name.ValueString(),
		Value:       plan.Value.ValueString(),
		Type:        plan.Type.ValueString(),
		Description: plan.Description.ValueString(),
	}

	tflog.Debug(ctx, "Creating a Component Property", map[string]any{
		"component":   componentID.String(),
		"group":       propertyReq.Group,
		"name":        propertyReq.Name,
		"value":       propertyReq.Value,
		"type":        propertyReq.Type,
		"description": propertyReq.Description,
	})
	propertyRes, err := r.client.Component.CreateProperty(ctx, componentID, propertyReq)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Creating Component Property.",
			"Unexpected error: "+err.Error(),
		)
		return
	}
	propertyState := componentPropertyResourceModel{
		ID:          types.StringValue(propertyRes.UUID.String()),
		Component:   types.StringValue(componentID.String()),
		Group:       types.StringValue(propertyRes.Group),
		Name:        types.StringValue(propertyRes.Name),
		Value:       types.StringValue(propertyRes.Value),
		Type:        types.StringValue(propertyRes.Type),
		Description: types.StringValue(propertyRes.Description),
	}
	if propertyRes.Type == PropertyTypeEncryptedString {
		propertyState.Value = plan.Value
	}

	diags = resp.State.Set(ctx, &propertyState)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Created a Component Property", map[string]any{
		"id":          propertyState.ID.ValueString(),
		"component":   propertyState.Component.ValueString(),
		"group":       propertyState.Group.ValueString(),
		"name":        propertyState.Name.ValueString(),
		"value":       propertyState.Value.ValueString(),
		"type":        propertyState.Type.ValueString(),
		"description": propertyState.Description.ValueString(),
	})
}

func (r *componentPropertyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state componentPropertyResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	componentID, diag := TryParseUUID(state.Component, LifecycleRead, path.Root("component"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	propertyID, diag := TryParseUUID(state.ID, LifecycleRead, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, "Reading Component Property", map[string]any{
		"id":          propertyID.String(),
		"component":   componentID.String(),
		"group":       state.Group.ValueString(),
		"name":        state.Name.ValueString(),
		"value":       state.Value.ValueString(),
		"type":        state.Type.ValueString(),
		"description": state.Description.ValueString(),
	})
	componentProperties, err := r.client.Component.GetProperties(ctx, componentID)
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Read, Unable to fetch Component Properties",
			"Error from: "+err.Error(),
		)
		return
	}
	componentProperty, err := Find(componentProperties, func(cp dtrack.ComponentProperty) bool {
		return cp.UUID == propertyID
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Read, Unable to identify Component Property",
			"Error from: "+err.Error(),
		)
		return
	}
	propertyState := componentPropertyResourceModel{
		ID:          types.StringValue(componentProperty.UUID.String()),
		Component:   types.StringValue(componentID.String()),
		Group:       types.StringValue(componentProperty.Group),
		Name:        types.StringValue(componentProperty.Name),
		Value:       types.StringValue(componentProperty.Value),
		Type:        types.StringValue(componentProperty.Type),
		Description: types.StringValue(componentProperty.Description),
	}
	if componentProperty.Type == PropertyTypeEncryptedString {
		propertyState.Value = state.Value
	}
	diags = resp.State.Set(ctx, &propertyState)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Read Component Property", map[string]any{
		"id":          propertyState.ID.ValueString(),
		"component":   propertyState.Component.ValueString(),
		"group":       propertyState.Group.ValueString(),
		"name":        propertyState.Name.ValueString(),
		"value":       propertyState.Value.ValueString(),
		"type":        propertyState.Type.ValueString(),
		"description": propertyState.Description.ValueString(),
	})
}

func (r *componentPropertyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	// DependencyTrack does not expose an API method to POST / PATCH `ComponentProperty`, as such, all attributes have been marked with `RequiresReplace`.
	var plan componentPropertyResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, "Updating Component Property", map[string]any{
		"id":        plan.ID.ValueString(),
		"component": plan.Component.ValueString(),
		"group":     plan.Group.ValueString(),
		"name":      plan.Name.ValueString(),
		"value":     plan.Value.ValueString(),
		"type":      plan.Type.ValueString(),
	})

	id, diag := TryParseUUID(plan.ID, LifecycleUpdate, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	componentID, diag := TryParseUUID(plan.Component, LifecycleUpdate, path.Root("component"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	if resp.Diagnostics.HasError() {
		return
	}

	property := dtrack.ComponentProperty{
		UUID:        id,
		Group:       plan.Group.ValueString(),
		Name:        plan.Name.ValueString(),
		Value:       plan.Value.ValueString(),
		Type:        plan.Type.ValueString(),
		Description: plan.Description.ValueString(),
	}

	state := componentPropertyResourceModel{
		ID:          types.StringValue(property.UUID.String()),
		Component:   types.StringValue(componentID.String()),
		Group:       types.StringValue(property.Group),
		Name:        types.StringValue(property.Name),
		Value:       types.StringValue(property.Value),
		Type:        types.StringValue(property.Type),
		Description: types.StringValue(property.Description),
	}
	if property.Type == PropertyTypeEncryptedString {
		state.Value = plan.Value
	}
	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Updated Component Property", map[string]any{
		"id":          state.ID.ValueString(),
		"component":   state.Component.ValueString(),
		"group":       state.Group.ValueString(),
		"name":        state.Name.ValueString(),
		"value":       state.Value.ValueString(),
		"type":        state.Type.ValueString(),
		"description": state.Description.ValueString(),
	})
}

func (r *componentPropertyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state componentPropertyResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	id, diag := TryParseUUID(state.ID, LifecycleDelete, path.Root("id"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	componentID, diag := TryParseUUID(state.Component, LifecycleDelete, path.Root("component"))
	if diag != nil {
		resp.Diagnostics.Append(diag)
	}
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, "Deleting Component Property", map[string]any{
		"id":          id.String(),
		"component":   componentID.String(),
		"group":       state.Group.ValueString(),
		"name":        state.Name.ValueString(),
		"type":        state.Type.ValueString(),
		"value":       state.Value.ValueString(),
		"description": state.Description.ValueString(),
	})

	err := r.client.Component.DeleteProperty(ctx, componentID, id)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to delete Component Property.",
			"Error from: "+err.Error(),
		)
		return
	}
	tflog.Debug(ctx, "Deleted Component Property", map[string]any{
		"id":          state.ID.ValueString(),
		"component":   state.Component.ValueString(),
		"group":       state.Group.ValueString(),
		"name":        state.Name.ValueString(),
		"value":       state.Value.ValueString(),
		"type":        state.Type.ValueString(),
		"description": state.Description.ValueString(),
	})
}

func (r *componentPropertyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	idParts := strings.Split(req.ID, "/")
	if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" {
		resp.Diagnostics.AddError(
			"Unexpected import id",
			"Expected id in format <ComponentID>/<PropertyID>. Received "+req.ID,
		)
		return
	}
	componentID, err := uuid.Parse(idParts[0])
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Import, unable to parse ComponentID as UUID",
			"Error from: "+err.Error(),
		)
	}
	propertyID, err := uuid.Parse(idParts[1])
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Import, unable to parse PropertyID as UUID",
			"Error from: "+err.Error(),
		)
	}
	if resp.Diagnostics.HasError() {
		return
	}

	componentProperties, err := r.client.Component.GetProperties(ctx, componentID)
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Read, Unable to fetch Component Properties",
			"Error from: "+err.Error(),
		)
		return
	}
	componentProperty, err := Find(componentProperties, func(cp dtrack.ComponentProperty) bool {
		return cp.UUID == propertyID
	})
	if err != nil {
		resp.Diagnostics.AddError(
			"Within Read, Unable to identify Component Property",
			"Error from: "+err.Error(),
		)
		return
	}
	propertyState := componentPropertyResourceModel{
		ID:        types.StringValue(componentProperty.UUID.String()),
		Component: types.StringValue(componentID.String()),
		Group:     types.StringValue(componentProperty.Group),
		Name:      types.StringValue(componentProperty.Name),
		// If Type == "ENCRYPTEDSTRING", then Value will be placeholder text.
		Value:       types.StringValue(componentProperty.Value),
		Type:        types.StringValue(componentProperty.Type),
		Description: types.StringValue(componentProperty.Description),
	}

	diags := resp.State.Set(ctx, propertyState)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, "Imported Component Property", map[string]any{
		"id":          propertyState.ID.ValueString(),
		"component":   propertyState.Component.ValueString(),
		"group":       propertyState.Group.ValueString(),
		"name":        propertyState.Name.ValueString(),
		"value":       propertyState.Value.ValueString(),
		"type":        propertyState.Type.ValueString(),
		"description": propertyState.Description.ValueString(),
	})
}

func (r *componentPropertyResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	clientInfoData, ok := req.ProviderData.(clientInfo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Configure Type",
			fmt.Sprintf("Expected provider.clientInfo, got %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = clientInfoData.client
	r.semver = clientInfoData.semver
}
